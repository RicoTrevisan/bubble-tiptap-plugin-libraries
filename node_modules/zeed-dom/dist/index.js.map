{"version":3,"sources":["../src/htmlparser.ts","../src/vdomparser.ts","../src/tidy.ts","../src/xml.ts","../src/manipulate.ts"],"sourcesContent":["// Taken from https://github.com/creeperyang/html-parser-lite\n// and slightly modified. Original also under MIT license. Thanks.\n\n// attribute, like href=\"javascript:void(0)\"\n// 1. start with name (not empty and not =)\n// 2. and then \\s*=\\s*\n// 3. and value can be \"value\" | 'value' | value\n// 4. 2 and 3 are optional\nconst attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/gm\nconst endTagRe = /^<\\/([^>\\s]+)[^>]*>/m\n// start tag, like <a href=\"link\"> <img/>\n// 1. must start with <tagName\n// 2. optional attrbutes\n// 3. /> or >\nconst startTagRe = /^<([^>\\s\\/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*\\/?\\s*>/m\nconst selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m\n\n/**\n * This is a simple html parser. Will read and parse html string.\n *\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nexport class HtmlParser {\n  scanner: any\n  options: any\n  attrRe = attrRe\n  endTagRe = endTagRe\n  startTagRe = startTagRe\n  defaults = { ignoreWhitespaceText: false }\n\n  constructor(options: {\n    scanner?: any\n    ignoreWhitespaceText?: boolean\n  } = {}) {\n    if (options.scanner)\n      this.scanner = options.scanner\n    this.options = Object.assign({}, this.defaults, options)\n  }\n\n  parse(html: string) {\n    let treatAsChars = false\n    let index, match, characters\n    while (html.length) {\n      // comment\n      if (html.substring(0, 4) === '<!--') {\n        index = html.indexOf('-->')\n        if (index !== -1) {\n          this.scanner.comment(html.substring(4, index))\n          html = html.substring(index + 3)\n          treatAsChars = false\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n      // end tag\n      else if (html.substring(0, 2) === '</') {\n        match = this.endTagRe.exec(html)\n        if (match) {\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseEndTag(RegExp.lastMatch, match[1])\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n      // start tag\n      else if (html.charAt(0) === '<') {\n        match = this.startTagRe.exec(html)\n        if (match) {\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseStartTag(RegExp.lastMatch, match[1], match)\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n\n      if (treatAsChars) {\n        index = html.indexOf('<')\n        let offset = index\n\n        if (index === 0) {\n          // First char is a < so find the next one\n          index = html.substring(1).indexOf('<')\n          // We're at substring(1) so add 1 to the index\n          offset = offset + 1\n        }\n\n        if (index === -1) {\n          characters = html\n          html = ''\n        }\n        else {\n          characters = html.substring(0, offset)\n          html = html.substring(offset)\n        }\n\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters))\n          this.scanner.characters(characters)\n      }\n\n      treatAsChars = true\n      match = null\n    }\n  }\n\n  parseStartTag(input: string, tagName: string, match: any) {\n    const isSelfColse = selfCloseTagRe.test(input)\n    let attrInput = match[2]\n    if (isSelfColse)\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, '')\n\n    const attrs = this.parseAttributes(tagName, attrInput)\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0])\n  }\n\n  parseEndTag(input: string, tagName: string) {\n    this.scanner.endElement(tagName)\n  }\n\n  parseAttributes(tagName: string, input: string) {\n    const attrs: Record<string, any> = {}\n    input.replace(this.attrRe, (...m: any[]) => {\n      const [_attr, name, _c2, value, _c4, valueInQuote, _c6, valueInSingleQuote] = m\n      attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true\n      return undefined as any // hack\n    })\n    return attrs\n  }\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\n/* eslint-disable n/prefer-global/buffer */\n\nimport { unescapeHTML } from './encoding'\nimport { SELF_CLOSING_TAGS } from './html'\nimport { HtmlParser } from './htmlparser'\nimport { hasOwn } from './utils'\nimport {\n  VDocType,\n  VDocumentFragment,\n  VElement,\n  VHTMLDocument,\n  VNode,\n  VTextNode,\n  document,\n} from './vdom'\n\n// Makes sure we operate on VNodes\nexport function vdom(obj: VNode | Buffer | string | null = null): VNode {\n  if (obj instanceof VNode)\n    return obj\n\n  if (obj instanceof Buffer)\n    obj = obj.toString('utf-8')\n\n  if (typeof obj === 'string')\n    return parseHTML(obj)\n\n  // console.warn('Cannot convert to VDOM:', obj)\n  return new VDocumentFragment()\n}\n\nexport function parseHTML(html: string): VDocumentFragment | VHTMLDocument {\n  if (typeof html !== 'string') {\n    console.error('parseHTML requires string, found', html)\n    throw new Error('parseHTML requires string')\n  }\n\n  const frag\n    = html.indexOf('<!') === 0 ? new VHTMLDocument(true) : new VDocumentFragment() // !hack\n\n  const stack: VNode[] = [frag]\n\n  const parser = new HtmlParser({\n    // the for methods must be implemented yourself\n    scanner: {\n      startElement(\n        tagName: string,\n        attrs: Record<string, string>,\n        isSelfClosing: boolean,\n      ) {\n        const lowerTagName = tagName.toLowerCase()\n\n        if (lowerTagName === '!doctype') {\n          frag.docType = new VDocType()\n          return\n        }\n\n        for (const name in attrs) {\n          if (hasOwn(attrs, name)) {\n            const value = attrs[name]\n            // console.log(name, value)\n            if (typeof value === 'string')\n              attrs[name] = unescapeHTML(value)\n          }\n        }\n        const parentNode = stack[stack.length - 1]\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs)\n          parentNode.appendChild(element)\n          if (\n            !(\n              SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing\n            )\n          )\n            stack.push(element)\n        }\n      },\n      endElement(_tagName: string) {\n        stack.pop()\n      },\n      characters(text: string) {\n        text = unescapeHTML(text)\n        const parentNode = stack[stack.length - 1]\n        if (parentNode?.lastChild?.nodeType === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text\n        }\n        else {\n          if (parentNode)\n            parentNode.appendChild(new VTextNode(text))\n            // } else {\n            //   console.trace(parentNode, stack)\n        }\n      },\n      comment(_text: string) {},\n    },\n  })\n  parser.parse(html)\n  // console.log(\"frag\", frag)\n  return frag\n}\n\n// export function parseHTML2(html) {\n//   let frag = new VDocumentFragment()\n//\n//   let stack = [frag]\n//   let currentElement = frag\n//\n//   let parser = new Parser({\n//     onopentag: (name, attrs) => {\n//       let element = document.createElement(name, attrs)\n//       stack.push(element)\n//       currentElement.appendChild(element)\n//       currentElement = element\n//     },\n//     ontext: function (text) {\n//       if (currentElement?.lastChild?.nodeType === VNode.TEXT_NODE) {\n//         currentElement.lastChild._text += text\n//       } else {\n//         currentElement.appendChild(new VTextNode(text))\n//       }\n//     },\n//     onclosetag: function (name) {\n//       let element = stack.pop()\n//       currentElement = stack[stack.length - 1]\n//       // if (element.nodeName !== currentElement.nodeName) {\n//       //   console.log('error', element, currentElement)\n//       // }\n//     },\n//   }, { decodeEntities: true })\n//   parser.write(html)\n//   parser.end()\n//\n//   // console.log('frag', frag.innerHTML)\n//\n//   return frag\n// }\n\nVElement.prototype.setInnerHTML = function (html) {\n  const frag = parseHTML(html)\n  this._childNodes = frag._childNodes\n  this._fixChildNodesParent()\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport type { VDocument } from './vdom'\nimport { VNode, VTextNode } from './vdom'\n\nconst SELECTOR_BLOCK_ELEMENTS\n  = 'meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form'\nconst TAGS_KEEP_CONTENT = ['PRE', 'CODE', 'SCRIPT', 'STYLE', 'TT']\n\nfunction level(element: VNode): string {\n  let indent = ''\n  while (element.parentNode) {\n    indent += '  '\n    element = element.parentNode\n  }\n  return indent.substr(2)\n}\n\nexport function tidyDOM(document: VDocument) {\n  document.handle(SELECTOR_BLOCK_ELEMENTS, (e) => {\n    // Ignore if inside PRE etc.\n    let ee = e\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName))\n        return\n      ee = ee.parentNode\n    }\n\n    const prev = e.previousSibling\n    if (\n      !prev\n      || prev.nodeType !== VNode.TEXT_NODE\n      || !prev.nodeValue?.endsWith('\\n')\n    )\n      e.parentNode?.insertBefore(new VTextNode('\\n'), e)\n\n    e.parentNode?.insertBefore(new VTextNode(level(e)), e)\n\n    const next = e.nextSibling\n    if (\n      !next\n      || next.nodeType !== VNode.TEXT_NODE\n      || !next.nodeValue?.startsWith('\\n')\n    ) {\n      if (next)\n        e.parentNode?.insertBefore(new VTextNode('\\n'), next)\n      else\n        e.parentNode?.appendChild(new VTextNode('\\n'))\n    }\n\n    if (e.childNodes.length) {\n      const first = e.firstChild\n      if (first.nodeType === VNode.TEXT_NODE)\n        e.insertBefore(new VTextNode(`\\n${level(e)}  `))\n\n      e.appendChild(new VTextNode(`\\n${level(e)}`))\n    }\n  })\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { hArgumentParser } from './h'\nimport { markup } from './html'\n\nexport function xml(itag: string, iattrs?: object, ...ichildren: any[]) {\n  const { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n  return markup(true, tag, attrs, children)\n}\n\n// export const xmlVDOM = markup.bind(null, true)\n\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\nxml.xml = true\n\nexport const h = xml\n","import type { VDocumentFragment, VHTMLDocument } from './vdom'\nimport { parseHTML } from './vdomparser'\n\nexport function handleHTML(html: string, handler: (document: VHTMLDocument | VDocumentFragment) => void) {\n  const document = parseHTML(html)\n  handler(document)\n  return document.render()\n}\n"],"mappings":"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","names":["html","html","document","html","document"]}